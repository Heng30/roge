import SQLite from 'react-native-sqlite-storage';
import axios from 'axios';

const DB_PATH = 'roge.db';
const DB = (() => {
  // SQLite.DEBUG(true);
  // SQLite.enablePromise(true);

  const db = SQLite.openDatabase({name: DB_PATH, location: 'default'});
  db.transaction(txn => {
    txn.executeSql(
      'CREATE TABLE IF NOT EXISTS price_mark (symbol TEXT UNIQUE NOT NULL)',
      [],
    );
    txn.executeSql(
      'CREATE TABLE IF NOT EXISTS setting (name TEXT UNIQUE NOT NULL, value TEXT NOT NULL)',
      [],
    );
    settingTable.init();
  });

  return db;
})();

const priceMarkTable = {
  load: cb => {
    DB.transaction(txn => {
      txn.executeSql('SELECT * FROM price_mark', [], (tx, results) => {
        const items = [];
        for (let i = 0; i < results.rows.length; i++)
          items.push(results.rows.item(i).symbol);
        cb(items);
      });
    });
  },

  insert: symbol => {
    DB.transaction(txn => {
      txn.executeSql('INSERT INTO price_mark (symbol) VALUES ($1)', [symbol]);
    });
  },
  delete: symbol => {
    DB.transaction(txn => {
      txn.executeSql('DELETE FROM price_mark where symbol=?', [symbol]);
    });
  },
};

const settingTable = {
  init: () => {
    DB.transaction(txn => {
      txn.executeSql('SELECT * FROM setting', [], (tx, results) => {
        let fontSizeFound = false,
          themeModeFound = false;
        let syncsvrAPIFound = false;
        for (let i = 0; i < results.rows.length; i++) {
          if (results.rows.item(i).name === 'fontSize') {
            fontSizeFound = true;
          }

          if (results.rows.item(i).name === 'themeMode') {
            themeModeFound = true;
          }

          if (results.rows.item(i).name === 'syncsvrAPI') {
            syncsvrAPIFound = true;
          }
        }

        if (!fontSizeFound)
          txn.executeSql('INSERT INTO setting (name, value) VALUES ($1, $2)', [
            'fontSize',
            '15',
          ]);

        if (!themeModeFound)
          txn.executeSql('INSERT INTO setting (name, value) VALUES ($1, $2)', [
            'themeMode',
            'light',
          ]);

        if (!syncsvrAPIFound)
          txn.executeSql('INSERT INTO setting (name, value) VALUES ($1, $2)', [
            'syncsvrAPI',
            '',
          ]);
      });
    });
  },

  load: cb => {
    DB.transaction(txn => {
      txn.executeSql('SELECT * FROM setting', [], (tx, results) => {
        const items = [];
        for (let i = 0; i < results.rows.length; i++) {
          items.push({
            name: results.rows.item(i).name,
            value: results.rows.item(i).value,
          });
        }
        cb(items);
      });
    });
  },

  get: (name, cb) => {
    DB.transaction(txn => {
      txn.executeSql('SELECT * FROM setting', [], (tx, results) => {
        for (let i = 0; i < results.rows.length; i++)
          if (results.rows.item(i).name === name) {
            cb(results.rows.item(i).value);
            return;
          }
      });
    });
  },
  update: (name, value) => {
    DB.transaction(txn => {
      txn.executeSql('UPDATE setting set value=? where name=?', [
        String(value),
        name,
      ]);
    });
  },
  delete: name => {
    DB.transaction(txn => {
      txn.executeSql('DELETE FROM setting where name=?', [name]);
    });
  },
};

const syncAllData = async cb => {
  const priceMarkTablePromise = new Promise((resolve, reject) => {
    let isResolve = false;
    setTimeout(() => {
      if (isResolve) return;
      reject(null);
    }, 3000);
    priceMarkTable.load(items => {
      isResolve = true;
      resolve([{name: 'priceMarkTable', value: items}]);
    });
  });

  const settingTablePromise = new Promise((resolve, reject) => {
    let isResolve = false;
    setTimeout(() => {
      if (isResolve) return;
      reject(null);
    }, 3000);
    settingTable.load(items => {
      isResolve = true;
      resolve(items);
    });
  });

  const dataList = [];
  let url = '';
  try {
    const res = await Promise.allSettled([
      priceMarkTablePromise,
      settingTablePromise,
    ]);

    let markCoins = [];
    res.forEach(item => {
      if (Array.isArray(item.value)) {
        item.value.forEach(it => {
          if (it.name === 'syncsvrAPI') url = it.value;

          if (it.name === 'priceMarkTable') markCoins = it.value;
          else dataList.push(it);
        });
      }
    });

    const respList = [];
    const values = [markCoins, dataList];
    ['markCoins', 'roge'].forEach(async (item, index) => {
      const rurl = url + '/' + item;
      const resp = await axios.post(rurl, JSON.stringify(values[index]), {
        headers: {
          'Content-Type': 'application/json',
        },
      });
        console.log("fj", resp.status)

      respList.push(resp);
    });

    const errors = [];
    respList.forEach(item => {
        console.log("fjie", item.status)
      if (item.status !== 200) {
        errors.push(item.data);
      } else {
        if (item.data.code !== 0) errors.push(item.data);
      }
    });

    cb(errors);
  } catch (e) {
      console.log("xx", e)

    cb(e);
  }
};

export default {
  priceMarkTable,
  settingTable,
  syncAllData,
};
